#!/usr/bin/env bash
set -euo pipefail

# Trigger-aware perf sampler for AutoFDO/Propeller pipelines.
# - Reads targets + triggers from /etc/gm-fdo-targets.conf
# - Records short system-wide chunks ONLY when trigger processes exist
# - Prefers branch-stack capture (best for sample-PGO + Propeller)
# - Falls back gracefully when the ideal event path is unavailable

CONF="/etc/gm-fdo-targets.conf"
[[ -f "$CONF" ]] || { echo "Missing $CONF" >&2; exit 1; }

# shellcheck disable=SC1090
source "$CONF"

GM_PERF_DIR="${GM_PERF_DIR:-/var/lib/gm/perf}"
mkdir -p "$GM_PERF_DIR/chunks" "$GM_PERF_DIR/state"

# Settings (from /etc/gm-fdo-targets.conf)
GM_PERF_DURATION_SEC="${GM_PERF_DURATION_SEC:-60}"
GM_PERF_IDLE_SEC="${GM_PERF_IDLE_SEC:-20}"

# Backward-compat: older configs used GM_PERF_SLEEP_SEC
if [[ -n "${GM_PERF_SLEEP_SEC:-}" ]]; then
  GM_PERF_IDLE_SEC="${GM_PERF_SLEEP_SEC}"
fi

# Sample period (-c). Prime avoids sync with other timers.
GM_PERF_PERIOD="${GM_PERF_PERIOD:-500009}"

log() { echo "[gm-perf] $*"; }

cpu_vendor() {
  awk -F: '/^vendor_id[[:space:]]*:/ {gsub(/^[[:space:]]+/, "", $2); print $2; exit}' /proc/cpuinfo 2>/dev/null || true
}

cpu_has_flag() {
  grep -qE "(^|[[:space:]])${1}([[:space:]]|$)" /proc/cpuinfo 2>/dev/null
}

perf_supports_pfm() {
  perf record --help 2>&1 | grep -q -- '--pfm-events'
}

perf_supports_event_substr() {
  perf list 2>/dev/null | grep -q "$1"
}

disable_capture() {
  local reason="$1"
  echo "$reason" >"$GM_PERF_DIR/state/capture_disabled.reason" 2>/dev/null || true
  log "Capture disabled: $reason"
}

clear_disable() {
  rm -f "$GM_PERF_DIR/state/capture_disabled.reason" 2>/dev/null || true
}

trigger_is_running() {
  local pat="$1"
  [[ -n "$pat" ]] || return 1

  # Your gm-fdo-targets.conf documents triggers as "pgrep -f patterns".
  # We make it robust:
  # - If pattern contains regex-ish characters or slashes, use -f
  # - Otherwise try -x (exact name) first, then -f
  if [[ "$pat" =~ [\.\*\+\?\[\]\(\)\|\^\\/] ]]; then
    pgrep -f -- "$pat" >/dev/null 2>&1
  else
    pgrep -x -- "$pat" >/dev/null 2>&1 || pgrep -f -- "$pat" >/dev/null 2>&1
  fi
}

triggers_any_running() {
  # GM_TARGETS is defined in /etc/gm-fdo-targets.conf as an array of:
  # name|atom|binary_glob|trigger1 trigger2 ...
  for entry in "${GM_TARGETS[@]:-}"; do
    IFS='|' read -r _name _atom _glob triggers <<<"$entry"
    for t in $triggers; do
      trigger_is_running "$t" && return 0
    done
  done
  return 1
}

choose_perf_cmd() {
  # Prefer branch-stack capture (best for AutoFDO + Propeller)
  # AMD (Zen3+BRS or Zen4+amd_lbr_v2): use libpfm event if available
  # Intel: use BR_INST_RETIRED.NEAR_TAKEN if available
  # Fallback: cycles (still useful for sample profiles; Propeller quality lower)

  local vendor
  vendor=$(cpu_vendor)

  if [[ "$vendor" == "GenuineIntel" ]]; then
    if perf_supports_event_substr "BR_INST_RETIRED.NEAR_TAKEN"; then
      echo "perf record -e BR_INST_RETIRED.NEAR_TAKEN -a -N -b -c ${GM_PERF_PERIOD}"
      return 0
    fi
    # fallback
    echo "perf record -e cycles -a -N -c ${GM_PERF_PERIOD}"
    return 0
  fi

  if [[ "$vendor" == "AuthenticAMD" ]]; then
    # If neither flag exists, branch-stack path likely unsupported on this CPU/kernel.
    if ! cpu_has_flag "brs" && ! cpu_has_flag "amd_lbr_v2"; then
      # fallback
      echo "perf record -e cycles -a -N -c ${GM_PERF_PERIOD}"
      return 0
    fi

    if perf_supports_pfm; then
      # Record both user+kernel branch events via libpfm
      echo "perf record --pfm-events RETIRED_TAKEN_BRANCH_INSTRUCTIONS:u,RETIRED_TAKEN_BRANCH_INSTRUCTIONS:k -a -N -b -c ${GM_PERF_PERIOD}"
      return 0
    fi

    # fallback if pfm missing
    echo "perf record -e cycles -a -N -c ${GM_PERF_PERIOD}"
    return 0
  fi

  # Unknown vendor: fallback
  echo "perf record -e cycles -a -N -c ${GM_PERF_PERIOD}"
  return 0
}

main() {
  local cmd
  cmd=$(choose_perf_cmd)
  clear_disable
  log "Using: $cmd"

  while true; do
    if triggers_any_running; then
      local ts out
      ts=$(date +%s)
      out="$GM_PERF_DIR/chunks/chunk_${ts}.data"
      log "Triggers active; recording ${GM_PERF_DURATION_SEC}s -> $out"

      # shellcheck disable=SC2086
      if ! $cmd -o "$out" -- sleep "$GM_PERF_DURATION_SEC"; then
        rm -f "$out" 2>/dev/null || true
        log "perf failed; will retry"
      fi

      sleep "$GM_PERF_IDLE_SEC"
    else
      sleep "$GM_PERF_IDLE_SEC"
    fi
  done
}

main "$@"
