#!/usr/bin/env bash
set -euo pipefail

# Process-aware trigger, system-wide capture:
# When any "trigger" process is running, we record a short perf chunk with
# branch stacks so llvm-profgen/create_llvm_prof can build AutoFDO/Propeller profiles.

CONF="/etc/gm-fdo-targets.conf"
[[ -f "$CONF" ]] || { echo "Missing $CONF" >&2; exit 1; }

# shellcheck disable=SC1090
source "$CONF"

GM_PERF_DIR="${GM_PERF_DIR:-/var/lib/gm/perf}"

# Settings (from /etc/gm-fdo-targets.conf)
GM_PERF_DURATION_SEC="${GM_PERF_DURATION_SEC:-60}"
GM_PERF_IDLE_SEC="${GM_PERF_IDLE_SEC:-20}"

# Backward-compat: older configs used GM_PERF_SLEEP_SEC
if [[ -n "${GM_PERF_SLEEP_SEC:-}" ]]; then
  GM_PERF_IDLE_SEC="${GM_PERF_SLEEP_SEC}"
fi

# Sample period for -c (prime to avoid sync). Can be overridden by env.
GM_PERF_PERIOD="${GM_PERF_PERIOD:-500009}"

mkdir -p "$GM_PERF_DIR/chunks" "$GM_PERF_DIR/state"

log() { echo "[gm-perf] $*"; }

cpu_vendor() {
  awk -F: '/^vendor_id[[:space:]]*:/ {gsub(/^[[:space:]]+/, "", $2); print $2; exit}' /proc/cpuinfo 2>/dev/null || true
}

cpu_has_flag() {
  # flags are whitespace-separated; we match whole words
  grep -qE "(^|[[:space:]])${1}([[:space:]]|$)" /proc/cpuinfo 2>/dev/null
}

perf_supports_pfm() {
  perf record --help 2>&1 | grep -q -- '--pfm-events'
}

perf_supports_event() {
  # best-effort: perf list output differs per kernel; match substring
  perf list 2>/dev/null | grep -q "$1"
}

disable_capture() {
  local reason="$1"
  echo "$reason" >"$GM_PERF_DIR/state/capture_disabled.reason" 2>/dev/null || true
  log "FDO/Propeller capture disabled: $reason"
}

clear_disable() {
  rm -f "$GM_PERF_DIR/state/capture_disabled.reason" 2>/dev/null || true
}

trigger_is_running() {
  local pat="$1"
  [[ -n "$pat" ]] || return 1

  # gm-fdo-targets.conf documents triggers as "pgrep -f patterns".
  # We keep it robust:
  #  - Try exact name match first for simple tokens (steam, gamescope, java, firefox)
  #  - Fall back to -f for anything that needs cmdline matching (minecraft, java args, etc.)
  if [[ "$pat" =~ [\.\*\+\?\[\]\(\)\|\^\\/] ]]; then
    pgrep -f -- "$pat" >/dev/null 2>&1
  else
    pgrep -x -- "$pat" >/dev/null 2>&1 || pgrep -f -- "$pat" >/dev/null 2>&1
  fi
}

triggers_any_running() {
  for entry in "${GM_TARGETS[@]:-}"; do
    IFS='|' read -r _name _atom _glob triggers <<<"$entry"
    for t in $triggers; do
      trigger_is_running "$t" && return 0
    done
  done
  return 1
}

choose_perf_cmd() {
  # For kernel AutoFDO/Propeller, Linux kernel docs specify vendor-specific
  # perf commands and AMD feature gating (Zen3+BRS or Zen4+amd_lbr_v2).
  # We follow those docs and disable capture when the required path is unavailable.
  # Intel:   perf record -e BR_INST_RETIRED.NEAR_TAKEN -a -N -b -c <count> ...
  # AMD:     perf record --pfm-events RETIRED_TAKEN_BRANCH_INSTRUCTIONS:u,k -a -N -b -c <count> ...
  #
  # Note: we record system-wide (-a) to cover user+kernel interactions for the gaming stack.

  local vendor
  vendor=$(cpu_vendor)

  if [[ "$vendor" == "GenuineIntel" ]]; then
    if perf_supports_event "BR_INST_RETIRED.NEAR_TAKEN"; then
      echo "perf record -e BR_INST_RETIRED.NEAR_TAKEN -a -N -b -c ${GM_PERF_PERIOD}"
      return 0
    fi
    return 1
  fi

  if [[ "$vendor" == "AuthenticAMD" ]]; then
    # Kernel docs: supported AMD systems are Zen3 with BRS or Zen4 with amd_lbr_v2.
    if ! cpu_has_flag "brs" && ! cpu_has_flag "amd_lbr_v2"; then
      return 2
    fi
    if perf_supports_pfm; then
      # Use libpfm event naming. Record both userspace and kernelspace samples.
      echo "perf record --pfm-events RETIRED_TAKEN_BRANCH_INSTRUCTIONS:u,RETIRED_TAKEN_BRANCH_INSTRUCTIONS:k -a -N -b -c ${GM_PERF_PERIOD}"
      return 0
    fi
    return 3
  fi

  # Unknown vendor (still x86): unsupported for this branch-stack pipeline.
  return 4
}

main() {
  local cmd rc
  cmd=""
  if cmd=$(choose_perf_cmd); then
    clear_disable
    log "Using: $cmd"
  else
    rc=$?
    case "$rc" in
      1) disable_capture "Intel CPU detected but event BR_INST_RETIRED.NEAR_TAKEN not available in perf list" ;;
      2) disable_capture "AMD CPU detected but missing required PMU flags (need Zen3+BRS or Zen4+amd_lbr_v2)" ;;
      3) disable_capture "AMD CPU detected and supports BRS/LBR, but perf lacks --pfm-events (libpfm support missing)" ;;
      *) disable_capture "Unsupported CPU vendor for branch-stack AutoFDO/Propeller capture (vendor_id=$(cpu_vendor))" ;;
    esac
  fi

  while true; do
    # If capture is disabled, keep checking periodically (kernel/perf updates may enable it later).
    if [[ -f "$GM_PERF_DIR/state/capture_disabled.reason" ]]; then
      sleep "$GM_PERF_IDLE_SEC"
      if cmd=$(choose_perf_cmd); then
        clear_disable
        log "Capture path is now available. Using: $cmd"
      fi
      continue
    fi

    if triggers_any_running; then
      local ts out
      ts=$(date +%s)
      out="$GM_PERF_DIR/chunks/chunk_${ts}.data"
      log "Triggers active; recording ${GM_PERF_DURATION_SEC}s -> $out"
      # shellcheck disable=SC2086
      $cmd -o "$out" -- sleep "$GM_PERF_DURATION_SEC" || {
        rm -f "$out" 2>/dev/null || true
        log "perf failed; will retry"
      }
      sleep "$GM_PERF_IDLE_SEC"
    else
      sleep "$GM_PERF_IDLE_SEC"
    fi
  done
}

main "$@"
