#!/usr/bin/env bash
set -euo pipefail

# Process-aware trigger, system-wide capture:
# When any "trigger" process is running, we record a short perf chunk with
# branch stacks so llvm-profgen/create_llvm_prof can build AutoFDO/Propeller profiles.

CONF="/etc/gm-fdo-targets.conf"
[[ -f "$CONF" ]] || { echo "Missing $CONF" >&2; exit 1; }

# shellcheck disable=SC1090
source "$CONF"

GM_PERF_DIR="${GM_PERF_DIR:-/var/lib/gm/perf}"
GM_PERF_DURATION_SEC="${GM_PERF_DURATION_SEC:-600}"
GM_PERF_SLEEP_SEC="${GM_PERF_SLEEP_SEC:-60}"

mkdir -p "$GM_PERF_DIR/chunks"

log() { echo "[gm-perf] $*"; }

triggers_any_running() {
  for entry in "${GM_TARGETS[@]:-}"; do
    IFS='|' read -r _name _atom _glob triggers <<<"$entry"
    for t in $triggers; do
      pgrep -x "$t" >/dev/null 2>&1 && return 0
    done
  done
  return 1
}

choose_perf_cmd() {
  # Prefer libpfm-based portable event naming when available.
  if perf record --help 2>&1 | grep -q -- '--pfm-events'; then
    # Branch stacks (-b) are important for Propeller; -N avoids symbolization overhead.
    echo "perf record --pfm-events RETIRED_TAKEN_BRANCH_INSTRUCTIONS:u,RETIRED_TAKEN_BRANCH_INSTRUCTIONS:k -a -N -b -c 500009"
  else
    # Fallback: sample cycles + LBR callchain + branch stack.
    echo "perf record -e cycles -a -j any -g --call-graph lbr,8"
  fi
}

main() {
  local cmd
  cmd=$(choose_perf_cmd)
  log "Using: $cmd"

  while true; do
    if triggers_any_running; then
      local ts out
      ts=$(date +%s)
      out="$GM_PERF_DIR/chunks/chunk_${ts}.data"
      log "Triggers active; recording $GM_PERF_DURATION_SEC s -> $out"
      # shellcheck disable=SC2086
      $cmd -o "$out" -- sleep "$GM_PERF_DURATION_SEC" || {
        rm -f "$out" 2>/dev/null || true
        log "perf failed; will retry"
      }
      sleep "$GM_PERF_SLEEP_SEC"
    else
      sleep "$GM_PERF_SLEEP_SEC"
    fi
  done
}

main "$@"
